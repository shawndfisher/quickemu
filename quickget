#!/usr/bin/env bash
# SC2317: Command appears to be unreachable. Check usage (or ignore if invoked indirectly).
#  - https://www.shellcheck.net/wiki/SC2317
#  - Disable globally because many functions are called indirectly
# shellcheck disable=SC2317
export LC_ALL=C

function cleanup() {
    if [ -n "$(jobs -p)" ]; then
        kill "$(jobs -p)" 2>/dev/null
    fi
}

function os_info() {
    echo "${INFO}"
}

function show_os_info() {
    echo
    echo -e "$(os_info "${1}" | cut -d'|' -f 1)"
    echo -e " - Credentials:\t$(os_info "${1}" | cut -d'|' -f 2)"
    echo -e " - Website:\t$(os_info "${1}" | cut -d'|' -f 3)"
    echo -e " - Description:\t$(os_info "${1}" | cut -d'|' -f 4)"
}

function pretty_name() {
    os_info "${1}" | cut -d'|' -f 1
}

# Just in case quickget want use it
function os_homepage() {
    os_info "${1}" | cut -d'|' -f 4
}

function error_specify_os() {
    echo "ERROR! You must specify an operating system."
    echo "- Supported Operating Systems:"
    os_support | fold -s -w "$(tput cols)"
    echo -e "\nTo see all possible arguments, use:\n   quickget -h  or  quickget --help"
    exit 1
}

function os_supported() {
    if [[ ! "$(os_support)" =~ ${OS} ]]; then
        echo -e "ERROR! ${OS} is not a supported OS.\n"
        os_support | fold -s -w "$(tput cols)"
        exit 1
    fi
}

function error_specify_release() {
    show_os_info "${OS}"
    echo -e "\nERROR! You must specify a release."
    if [[ $(type -t "dist_releases") == function ]]; then
        echo -en " - Releases:\t"
        dist_releases | sed -Ee 's/eol-\S+//g' # hide eol releases
    fi
    if [[ $(type -t "dist_editions") == function ]]; then
        echo -en " - Editions:\t"
        dist_editions
    fi
    exit 1
}

function error_specify_edition() {
    show_os_info "${OS}"
    echo -e " - Editions:\t$("dist_editions" | fold -s -w "$(tput cols)")"
    echo -e "\nERROR! You must specify an edition."
    exit 1
}

function error_not_supported_release() {
    if [[ ! "${RELEASES[*]}" =~ ${RELEASE} ]]; then
        echo -e "ERROR! ${DISPLAY_NAME} ${RELEASE} is not a supported release.\n"
        echo -n ' - Supported releases: '
        "dist_releases"
        exit 1
    fi
}

function error_not_supported_edition() {
    if [[ ! "${EDITIONS[*]}" =~ ${EDITION} ]]; then
        echo -e "ERROR! ${EDITION} is not a supported $(pretty_name "${OS}") edition\n"
        echo -n ' - Supported editions: '
        for EDITION in "${EDITIONS[@]}"; do
            echo -n "${EDITION} "
        done
        echo ""
        exit 1
    fi
}

function error_not_supported_lang() {
    echo -e "ERROR! ${I18N} is not a supported $(pretty_name "${OS}") language\n"
    echo -n ' - Editions: '
    for I18N in "${I18NS[@]}"; do
        echo -n "${I18N} "
    done
    exit 1
}

function error_not_supported_argument() {
    echo "ERROR! Not supported argument"
    echo "To see all possible arguments, use:"
    echo "   quickget -h  or  quickget --help"
    exit 1
}

function validate_release() {
    local DISPLAY_NAME=""
    local RELEASES=""

    DISPLAY_NAME="$(pretty_name "${OS}")"
    RELEASES=$(dist_releases)

    if [[ $(type -t "dist_validate") == function ]]; then
        dist_validate
    else
        error_not_supported_release
    fi
}

function list_json() {
    # Reference: https://stackoverflow.com/a/67359273
    list_csv | jq -R 'split(",") as $h|reduce inputs as $in ([]; . += [$in|split(",")|. as $a|reduce range(0,length) as $i ({};.[$h[$i]]=$a[$i])])'
    exit 0
}

function list_csv() {
    CSV_DATA="$(csv_data)"

    echo "Display Name,OS,Release,Option,Downloader,PNG,SVG"
    sort -t',' -k2,2 <<<"${CSV_DATA}"

    exit 0
}

function csv_data() {
    local DISPLAY_NAME
    local DL=""
    local DOWNLOADER
    local OPTION
    local OS
    local PNG
    local RELEASE
    local SVG
    local HAS_ZSYNC=0

    # Check if zsync is available
    if command -v zsync &>/dev/null; then
        HAS_ZSYNC=1
    fi

    for OS in $(os_support); do
        local EDITIONS=""
        source $(dirname "$0")/dist/${OS}
        DISPLAY_NAME="$(pretty_name "${OS}")"

        PNG="https://quickemu-project.github.io/quickemu-icons/png/${OS}/${OS}-quickemu-white-pinkbg.png"
        SVG="https://quickemu-project.github.io/quickemu-icons/svg/${OS}/${OS}-quickemu-white-pinkbg.svg"

        if [[ $(type -t "dist_editions") == function ]]; then
            EDITIONS=$(dist_editions)
        fi

        for RELEASE in $(dist_releases | sed -Ee 's/eol-\S+//g' ); do # hide eol releases
            if [[ "${OS}" == *"ubuntu"* ]] && [[ ${RELEASE} == *"daily"*  ]] && [ ${HAS_ZSYNC} -eq 1 ]; then
                DOWNLOADER="zsync"
            else
                DOWNLOADER="${DL}"
            fi

            # If the OS has an editions_() function, use it.
            if [[ ${EDITIONS} ]]; then
                for OPTION in ${EDITIONS}; do
                    echo "${DISPLAY_NAME},${OS},${RELEASE},${OPTION},${DOWNLOADER},${PNG},${SVG}"
                done
            elif [[ "${OS}" == "windows"* ]]; then
                "dist_languages"
                for I18N in "${I18NS[@]}"; do
                    echo "${DISPLAY_NAME},${OS},${RELEASE},${I18N},${DOWNLOADER},${PNG},${SVG}"
                done
            else
                echo "${DISPLAY_NAME},${OS},${RELEASE},,${DOWNLOADER},${PNG},${SVG}"
            fi
        done &
    done
    wait
}

#TODO
function create_config() {
    local OS="${1}"
    local DESTINATION="${2}"
    local USE

    if [[ "${DESTINATION}" == "http://"* ]] || [[ "${DESTINATION}" == "https://"* ]]; then
        web_get "${DESTINATION}" "${OS}"
        echo "#TODO: create config!"
    elif [[ "${DESTINATION}" == "/"* ]]; then
        cp "${OS}" "${DESTINATION}"/
        echo "#TODO: create config!"
    else
        echo "You forget write full path?" && exit 1
    fi
    exit 0
}

function list_supported() {
    list_csv | cut -d ',' -f2,3,4 | tr ',' ' '
    exit 0
}

function test_result() {
    local OS="${1}"
    local RELEASE="${2}"
    local EDITION="${3:-}"
    local URL="${4:-}"
    local RESULT="${5:-}"
    if [ -n "${EDITION}" ]; then
        OS="${OS}-${RELEASE}-${EDITION}"
    else
        OS="${OS}-${RELEASE}"
    fi

    if [ -n "${RESULT}" ]; then
        # Pad the OS string for consistent output
        OS=$(printf "%-35s" "${OS}")
        echo -e "${RESULT}: ${OS} ${URL}"
    else
        OS=$(printf "%-36s" "${OS}:")
        echo -e "${OS} ${URL}"
    fi
}

function test_all() {
    OS="${1}"
    os_supported

    local CHECK=""
    local URL=""

    source $(dirname "$0")/dist/${OS}
    for RELEASE in $(dist_releases | sed -Ee 's/eol-\S+//g' ); do # hide eol releases
        if [[ $(type -t "dist_editions") == function ]]; then
            for EDITION in $("dist_editions"); do
                validate_release
                URL=$(dist_image_get | cut -d' ' -f1 | head -n 1)
                if [ "${OPERATION}" == "show" ]; then
                    test_result "${OS}" "${RELEASE}" "${EDITION}" "${URL}"
                elif [ "${OPERATION}" == "test" ]; then
                    CHECK=$(web_check "${URL}" && echo "PASS" || echo "FAIL")
                    test_result "${OS}" "${RELEASE}" "${EDITION}" "${URL}" "${CHECK}"
                fi
            done
        else
            validate_release
            URL=$(dist_image_get | cut -d' ' -f1 | head -n 1)
            if [ "${OPERATION}" == "show" ]; then
                test_result "${OS}" "${RELEASE}" "${EDITION}" "${URL}"
            elif [ "${OPERATION}" == "test" ]; then
                CHECK=$(web_check "${URL}" && echo "PASS" || echo "FAIL")
                test_result "${OS}" "${RELEASE}" "${EDITION}" "${URL}" "${CHECK}"
            fi
        fi
    done
}

function os_support() {
    search_dir=$(dirname "$0")/dist
    for entry in "$search_dir"/*
    do
        distros+="$(basename $entry) "
    done
    echo ${distros[@]}
}

function check_hash() {
    local iso=""
    local hash=""
    local hash_algo=""
    if [ "${OPERATION}" == "download" ]; then
        iso="${1}"
    else
        iso="${VM_PATH}/${1}"
    fi
    hash="${2}"
    # Guess the hash algorithm by the hash length
    case ${#hash} in
        32) hash_algo=md5sum;;
        40) hash_algo=sha1sum;;
        64) hash_algo=sha256sum;;
        128) hash_algo=sha512sum;;
        *) echo "WARNING! Can't guess hash algorithm, not checking ${iso} hash."
            return;;
    esac
    echo -n "Checking ${iso} with ${hash_algo}... "
    if ! echo "${hash} ${iso}" | ${hash_algo} --check --status; then
        echo "ERROR!"
        echo "${iso} doesn't match ${hash}. Try running 'quickget' again."
        exit 1
    else
        echo "Good!"
    fi
}

# Download a file from the web and pipe it to stdout
function web_pipe() {
    curl --silent --location "${1}"
}

# Download a file from the web
function web_get() {
    local CHECK=""
    local HEADERS=()
    local URL="${1}"
    local DIR="${2}"
    local FILE=""
    local USER_AGENT="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36"

    # if no 3rd parameter, delete everything to late '/' in URL and use as FILE
    if [ -n "${3}" ]; then
        FILE="${3}"
    else
        FILE="${URL##*/}"
    fi

    # echo "web_get URL ${URL}"   >&2
    # echo "web_get DIR ${DIR}"   >&2
    # echo "web_get FILE ${FILE}" >&2

    # Process any URL redirections after the file name has been extracted
    URL=$(web_redirect "${URL}")

    # Process any headers
    while (( "$#" )); do
        if [ "${1}" == "--header" ]; then
            HEADERS+=("${1}" "${2}")
            shift 2
        else
            shift
        fi
    done

    # Test mode for ISO
    if [ "${OPERATION}" == "show" ]; then
        test_result "${OS}" "${RELEASE}" "${EDITION}" "${URL}"
        exit 0
    elif [ "${OPERATION}" == "test" ]; then
        CHECK=$(web_check "${URL}" && echo "PASS" || echo "FAIL")
        test_result "${OS}" "${RELEASE}" "${EDITION}" "${URL}" "${CHECK}"
        exit 0
    elif [ "${OPERATION}" == "download" ]; then
        DIR="$(pwd)"
    fi

    if [ "${DIR}" != "$(pwd)" ] && ! mkdir -p "${DIR}" 2>/dev/null; then
        echo "ERROR! Unable to create directory ${DIR}"
        exit 1
    fi

    if [[ ${OS} != windows && ${OS} != macos && ${OS} != windows-server ]]; then
        echo "Downloading $(pretty_name "${OS}") ${RELEASE} ${EDITION}"
        echo "- URL: ${URL}"
    fi

    if ! curl --progress-bar --location --output "${DIR}/${FILE}" --continue-at - --user-agent "${USER_AGENT}" "${HEADERS[@]}" -- "${URL}"; then
        echo "ERROR! Failed to download ${URL} with curl."
        rm -f "${DIR}/${FILE}"
    fi
}

# checks if a URL needs to be redirected and returns the final URL
function web_redirect() {
    local REDIRECT_URL=""
    local URL="${1}"
    # Check for URL redirections
    # Output to nonexistent directory so the download fails fast
    REDIRECT_URL=$(curl --silent --location --fail --write-out '%{url_effective}' --output /var/cache/${RANDOM}/${RANDOM} "${URL}")
    if [ "${REDIRECT_URL}" != "${URL}" ]; then
        echo "${REDIRECT_URL}"
    else
        echo "${URL}"
    fi
}

# checks if a URL is reachable
function web_check() {
    local HEADERS=()
    local URL="${1}"
    # Process any headers
    while (( "$#" )); do
        if [ "${1}" == "--header" ]; then
            HEADERS+=("${1}" "${2}")
            shift 2
        else
            shift
        fi
    done
    curl --silent --location --head --output /dev/null --fail --connect-timeout 30 --max-time 30 --retry 3 "${HEADERS[@]}" "${URL}"
}

function zsync_get() {
    local CHECK=""
    local DIR="${2}"
    local FILE="${1##*/}"
    local OUT=""
    local URL="${1}"
    # Test mode for ISO
    if [ "${OPERATION}" == "show" ]; then
        test_result "${OS}" "${RELEASE}" "${EDITION}" "${URL}"
        exit 0
    elif [ "${OPERATION}" == "test" ]; then
        CHECK=$(web_check "${URL}" && echo "PASS" || echo "FAIL")
        test_result "${OS}" "${RELEASE}" "${EDITION}" "${URL}" "${CHECK}"
        exit 0
    elif command -v zsync &>/dev/null; then
        if [ -n "${3}" ]; then
            OUT="${3}"
        else
            OUT="${FILE}"
        fi

        if ! mkdir -p "${DIR}" 2>/dev/null; then
            echo "ERROR! Unable to create directory ${DIR}"
            exit 1
        fi
        echo "Downloading $(pretty_name "${OS}") ${RELEASE} ${EDITION} from ${URL}"
        # Only force http for zsync - not earlier because we might fall through here
        if ! zsync "${URL/https/http}.zsync" -i "${DIR}/${OUT}" -o "${DIR}/${OUT}" 2>/dev/null; then
            echo "ERROR! Failed to download ${URL/https/http}.zsync"
            exit 1
        fi

        if [ -e "${DIR}/${OUT}.zs-old" ]; then
            rm "${DIR}/${OUT}.zs-old"
        fi
    else
        echo "INFO: zsync not found, falling back to curl"
        if [ -n "${3}" ]; then
            web_get "${1}" "${2}" "${3}"
        else
            web_get "${1}" "${2}"
        fi
    fi
}

function make_vm_config() {
    local CONF_FILE=""
    local IMAGE_FILE=""
    local ISO_FILE=""
    local SEC_BOOT=""
    if [ "${OPERATION}" == "download" ]; then
        exit 0
    fi
    IMAGE_FILE="${1}"
    ISO_FILE="${2}"

    if [ -z "${GUEST}" ]; then
        GUEST="linux"
    fi

    if [ -z "${IMAGE_TYPE}" ]; then
        IMAGE_TYPE="iso"
    fi

    CONF_FILE="${OS}-${RELEASE}.conf"
    if [ -n "${EDITION}" ]; then
        CONF_FILE="${OS}-${RELEASE}-${EDITION}.conf"
    fi

    if [ ! -e "${CONF_FILE}" ]; then
        echo "Making ${CONF_FILE}"
        cat << EOF > "${CONF_FILE}"
#!$(which quickemu) --vm
guest_os="${GUEST}"
disk_img="${VM_PATH}/disk.qcow2"
${IMAGE_TYPE}="${VM_PATH}/${IMAGE_FILE}"
EOF
        echo " - Setting ${CONF_FILE} executable"
        chmod u+x "${CONF_FILE}"
        if [ -n "${ISO_FILE}" ]; then
            echo "fixed_iso=\"${VM_PATH}/${ISO_FILE}\"" >> "${CONF_FILE}"
        fi

        # OS specific tweaks
        if [[ $(type -t "dist_vm_option_tweak") == function ]]; then
            dist_vm_option_tweak
        fi
    fi
    echo -e "\nTo start your $(pretty_name "${OS}") virtual machine run:"
    if [ "${OS}" == "slint" ]; then
        echo -e "    quickemu --vm ${CONF_FILE}\nTo start Slint with braille support run:\n    quickemu --vm --braille --display sdl ${CONF_FILE}"
    else
        echo "    quickemu --vm ${CONF_FILE}"
    fi

    echo
    exit 0
}

function open_homepage() {
    local URL=""
    local XDG_OPEN=""
    if [ -z "$(os_info "${1}")" ]; then
        error_specify_os
    else
        URL="$(os_info "${1}" | cut -d'|' -f 4)"
        # shellcheck disable=SC2034
        XDG_OPEN=$(xdg-open "${URL}" || sensible-browser "${URL}" || x-www-browser "${URL}" || gnome-open "${URL}")
        exit 0
    fi
}

function create_vm() {
    # shellcheck disable=SC2206
    local URL_HASH=(${1// / })
    local URL="${URL_HASH[0]}"
    local HASH="${URL_HASH[1]}"
    local ISO="${URL##*/}"

    if [[ -z "$1" ]]; then
        echo "create_vm: Bad URL"
        exit 1
    fi

    # echo "create_vm URL ${URL}"   >&2
    # echo "create_vm ISO ${ISO}"   >&2
    # echo "create_vm HASH ${HASH}" >&2

    if [[ $URL == *"drive.usercontent.google.com"* ]] || [[ $URL == *"microsoft.com"* ]]; then
        local FILE="${URL##*/}"
        URL="${URL%/${FILE}}"
        ISO=${FILE}
        web_get "${URL}" "${VM_PATH}" "${FILE}"
    else
        web_get "${URL}" "${VM_PATH}"
    fi

    if [ -n "${HASH}" ]; then
        check_hash "${ISO}" "${HASH}"
    fi

    if [[ $(type -t "dist_image_post_get") == function ]]; then
        dist_image_post_get
    fi
    make_vm_config "${ISO}"
}

function help_message() {
    #shellcheck disable=SC2016
    printf '
             _      _              _
  __ _ _   _(_) ___| | ____ _  ___| |_
 / _` | | | | |/ __| |/ / _` |/ _ \ __|
| (_| | |_| | | (__|   < (_| |  __/ |_
 \__, |\__,_|_|\___|_|\_\__, |\___|\__|
    |_|                 |___/ v%s, using curl %s
--------------------------------------------------------------------------------
 Project - https://github.com/quickemu-project/quickemu
 Discord - https://wimpysworld.io/discord
--------------------------------------------------------------------------------

Usage:
  quickget <os> <release> [edition]
  quickget ubuntu 22.04

Advanced usage:
  quickget <arg> [path] <os> [release] [edition]
  quickget --download ubuntu 22.04

Arguments:
  --download      <os> <release> [edition] : Download image; no VM configuration
  --create-config <os> [path/url]          : Create VM config for a OS image
  --open-homepage <os>                     : Open homepage for the OS
  --show          [os]                     : Show OS information
  --version                                : Show version
  --help                                   : Show this help message
-------------------------- For testing & development ---------------------------
  --url           [os] [release] [edition] : Show image URL(s)
  --check         [os] [release] [edition] : Check image URL(s)
  --list                                   : List all supported systems
  --list-csv                               : List everything in csv format
  --list-json                              : List everything in json format
--------------------------------------------------------------------------------

Supported Operating Systems:\n\n' "$(quickemu --version)" "${CURL_VERSION}"
    os_support | fold -s -w "$(tput cols)"
}

trap cleanup EXIT

if ((BASH_VERSINFO[0] < 4)); then
    echo "Sorry, you need bash 4.0 or newer to run this script."
    exit 1
fi

I18NS=()
OPERATION=""
CURL=$(command -v curl)
if [ ! -x "${CURL}" ]; then
    echo "ERROR! curl not found. Please install curl"
    exit 1
fi
CURL_VERSION=$("${CURL}" --version | head -n 1 | cut -d' ' -f2)

QEMU_IMG=$(command -v qemu-img)
if [ ! -x "${QEMU_IMG}" ]; then
    echo "ERROR! qemu-img not found. Please make sure qemu-img is installed."
    exit 1
fi

#TODO: Deprecate `list`, `list_csv`, and `list_json` in favor of `--list`, `--list-csv`, and `--list-json`
case "${1}" in
    --download|-download)
        OPERATION="download"
        shift
        ;;
    --create-config|-create-config)
        OPERATION="config"
        shift
        create_config "${@}"
        ;;
    --open-homepage|-open-homepage)
        shift
        open_homepage "${1}"
        ;;
    --show|-show)
        shift
        if [ -z "${1}" ]; then
            for OS in $(os_support); do
                show_os_info "${OS}"
            done
        else
            show_os_info "${1}"
        fi
        exit 0;;
    --version|-version)
        WHERE=$(dirname "${BASH_SOURCE[0]}")
        "${WHERE}/quickemu" --version
        exit 0;;
    --help|-help|--h|-h)
        help_message
        exit 0;;
    --url|-url)
        OPERATION="show"
        shift
        if [ -z "${1}" ]; then
            for OS in $(os_support); do
                (test_all "${OS}")
            done
            exit 0
        elif [ -z "${2}" ]; then
            test_all "${1}"
            exit 0
        fi;;
    --check|-check)
        OPERATION="test"
        shift
        if [ -z "${1}" ]; then
            for OS in $(os_support); do
                (test_all "${OS}")
            done
            exit 0
        elif [ -z "${2}" ]; then
            test_all "${1}"
            exit 0
        fi;;
    --list-csv|-list-csv|list|list_csv) list_csv;;
    --list-json|-list-json|list_json) list_json;;
    --list|-list) list_supported;;
    -*) error_not_supported_argument;;
esac

if [ -n "${1}" ]; then
    OS="${1,,}"
else
    error_specify_os
fi

# Source the OS' dist file
if [ -e $(dirname "$0")/dist/${OS} ]; then
    source $(dirname "$0")/dist/${OS}
fi

os_supported

if [ -n "${2}" ]; then
    RELEASE="${2}"
    VM_PATH="${OS}-${RELEASE}"
    # If the OS has an dist_editions() function, use it.
    if [[ $(type -t "dist_editions") == function ]]; then
        EDITIONS=$(dist_editions)
        EDITION=${EDITIONS[0]}
        if [ -n "${3}" ]; then
            EDITION="${3}"
            error_not_supported_edition
        else
            error_specify_edition
        fi
        VM_PATH="${OS}-${RELEASE}-${EDITION}"
    fi

    validate_release
    if [[ $(type -t "dist_image_pre_get") == function ]]; then
        dist_image_pre_get
    fi

    create_vm "$("dist_image_get")"
else
    error_specify_release
fi

# vim:tabstop=4:shiftwidth=4:expandtab
